{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _wrapNativeSuper from \"@babel/runtime/helpers/esm/wrapNativeSuper\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nimport axios from 'axios';\nvar codeMessage = {\n  200: '服务器成功返回请求的数据。',\n  201: '新建或修改数据成功。',\n  202: '一个请求已经进入后台排队（异步任务）。',\n  204: '删除数据成功。',\n  400: '发出的请求有错误，服务器没有进行新建或修改数据的操作。',\n  401: '用户没有权限（令牌、用户名、密码错误）。',\n  403: '用户得到授权，但是访问是被禁止的。',\n  404: '发出的请求针对的是不存在的记录，服务器没有进行操作。',\n  406: '请求的格式不可得。',\n  410: '请求的资源被永久删除，且不会再得到的。',\n  422: '当创建一个对象时，发生一个验证错误。',\n  500: '服务器发生错误，请检查服务器。',\n  502: '网关错误。',\n  503: '服务不可用，服务器暂时过载或维护。',\n  504: '网关超时。'\n};\n/**\n * 封装请求响应 Error\n */\n\nexport var ResError = /*#__PURE__*/function (_Error) {\n  _inherits(ResError, _Error);\n\n  var _super = _createSuper(ResError);\n\n  function ResError(resErrorConfig) {\n    var _this;\n\n    _classCallCheck(this, ResError);\n\n    var status = resErrorConfig.status,\n        message = resErrorConfig.message,\n        errorCode = resErrorConfig.errorCode,\n        requestUrl = resErrorConfig.requestUrl;\n    _this = _super.call(this, message);\n\n    _defineProperty(_assertThisInitialized(_this), \"status\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"errorCode\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"requestUrl\", void 0);\n\n    _this.status = status;\n    _this.errorCode = errorCode;\n    _this.requestUrl = requestUrl;\n    return _this;\n  }\n\n  return ResError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n/**\n * 封装 axios, 对外提供统一的 http 请求工具\n * 支持 get, post, put, patch, delete\n */\n\nvar Http = /*#__PURE__*/function () {\n  /**\n   * create a request instance\n   *\n   * @param {Object} options\n   * @param {Object} options.defaults axios的默认设置\n   * @param {Object} options.interceptors 拦截器设置\n   */\n  function Http(_ref) {\n    var _ref$defaults = _ref.defaults,\n        defaults = _ref$defaults === void 0 ? {} : _ref$defaults,\n        _ref$interceptors = _ref.interceptors,\n        interceptors = _ref$interceptors === void 0 ? {} : _ref$interceptors;\n\n    _classCallCheck(this, Http);\n\n    _defineProperty(this, \"instance\", void 0);\n\n    // eslint-disable-next-line no-multi-assign\n    var instance = this.instance = axios.create(_objectSpread(_objectSpread({}, defaults), {}, {\n      timeout: 50000\n    }));\n    instance.interceptors.request.use(function (cfg) {\n      return cfg;\n    }, function (err) {\n      return Promise.reject(err);\n    });\n    /**\n     * 请求失败拦截器 检验是什么类型的错误 网络错误或者自定义错误\n     * @param {AxiosError} err\n     * @returns {Promise<ResError>}\n     */\n\n    function resErrorFn(err) {\n      var response = err.response,\n          request = err.request;\n      var errorParams;\n\n      if (response) {\n        var _response$data = response.data,\n            data = _response$data === void 0 ? {} : _response$data,\n            status = response.status;\n        var resultMsg = data.resultMsg;\n        var errorText = resultMsg || codeMessage[status] || response.statusText;\n        errorParams = {\n          status: status,\n          message: errorText,\n          errorCode: status,\n          requestUrl: request.url\n        };\n      } else {\n        errorParams = {\n          status: 9999,\n          message: '网络错误',\n          errorCode: 9999,\n          requestUrl: request.url\n        };\n      }\n\n      return Promise.reject(new ResError(errorParams));\n    }\n\n    instance.interceptors.response.use(interceptors.resHandler || function (res) {\n      return res;\n    }, interceptors.errHandler || resErrorFn);\n  }\n\n  _createClass(Http, [{\n    key: \"head\",\n    value: function head(url) {\n      return this.instance.head(url);\n    }\n  }, {\n    key: \"get\",\n    value: function () {\n      var _get = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(url) {\n        var params,\n            config,\n            res,\n            _args = arguments;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                params = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};\n                config = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};\n                _context.next = 4;\n                return this.instance.get(url, _objectSpread(_objectSpread({}, config), {}, {\n                  params: params\n                }));\n\n              case 4:\n                res = _context.sent;\n                return _context.abrupt(\"return\", res.data);\n\n              case 6:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function get(_x) {\n        return _get.apply(this, arguments);\n      }\n\n      return get;\n    }()\n  }, {\n    key: \"delete\",\n    value: function _delete(url) {\n      return this.instance[\"delete\"](url);\n    }\n  }, {\n    key: \"post\",\n    value: function () {\n      var _post = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(url, data, config) {\n        var res;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this.instance.post(url, data, config);\n\n              case 2:\n                res = _context2.sent;\n                return _context2.abrupt(\"return\", res.data);\n\n              case 4:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function post(_x2, _x3, _x4) {\n        return _post.apply(this, arguments);\n      }\n\n      return post;\n    }()\n  }, {\n    key: \"put\",\n    value: function put(url, data, config) {\n      return this.instance.put(url, data, config);\n    }\n  }, {\n    key: \"patch\",\n    value: function patch(url, data, config) {\n      return this.instance.patch(url, data, config);\n    }\n  }]);\n\n  return Http;\n}();\n\nexport { Http as default };","map":null,"metadata":{},"sourceType":"module"}