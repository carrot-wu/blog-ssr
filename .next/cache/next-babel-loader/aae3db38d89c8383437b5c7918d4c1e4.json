{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport axios from 'axios';\nconst codeMessage = {\n  200: '服务器成功返回请求的数据。',\n  201: '新建或修改数据成功。',\n  202: '一个请求已经进入后台排队（异步任务）。',\n  204: '删除数据成功。',\n  400: '发出的请求有错误，服务器没有进行新建或修改数据的操作。',\n  401: '用户没有权限（令牌、用户名、密码错误）。',\n  403: '用户得到授权，但是访问是被禁止的。',\n  404: '发出的请求针对的是不存在的记录，服务器没有进行操作。',\n  406: '请求的格式不可得。',\n  410: '请求的资源被永久删除，且不会再得到的。',\n  422: '当创建一个对象时，发生一个验证错误。',\n  500: '服务器发生错误，请检查服务器。',\n  502: '网关错误。',\n  503: '服务不可用，服务器暂时过载或维护。',\n  504: '网关超时。'\n};\n/**\n * 封装请求响应 Error\n */\n\nexport class ResError extends Error {\n  constructor(resErrorConfig) {\n    const {\n      status,\n      message,\n      errorCode,\n      requestUrl\n    } = resErrorConfig;\n    super(message);\n\n    _defineProperty(this, \"status\", void 0);\n\n    _defineProperty(this, \"errorCode\", void 0);\n\n    _defineProperty(this, \"requestUrl\", void 0);\n\n    this.status = status;\n    this.errorCode = errorCode;\n    this.requestUrl = requestUrl;\n  }\n\n}\n/**\n * 封装 axios, 对外提供统一的 http 请求工具\n * 支持 get, post, put, patch, delete\n */\n\nexport default class Http {\n  /**\n   * create a request instance\n   *\n   * @param {Object} options\n   * @param {Object} options.defaults axios的默认设置\n   * @param {Object} options.interceptors 拦截器设置\n   */\n  constructor({\n    defaults = {},\n    interceptors = {}\n  }) {\n    _defineProperty(this, \"instance\", void 0);\n\n    // eslint-disable-next-line no-multi-assign\n    const instance = this.instance = axios.create(_objectSpread(_objectSpread({}, defaults), {}, {\n      timeout: 50000\n    }));\n    instance.interceptors.request.use(cfg => cfg, err => Promise.reject(err));\n    /**\n     * 请求失败拦截器 检验是什么类型的错误 网络错误或者自定义错误\n     * @param {AxiosError} err\n     * @returns {Promise<ResError>}\n     */\n\n    function resErrorFn(err) {\n      const {\n        response,\n        request\n      } = err;\n      let errorParams;\n\n      if (response) {\n        const {\n          data = {},\n          status\n        } = response;\n        const {\n          resultMsg\n        } = data;\n        const errorText = resultMsg || codeMessage[status] || response.statusText;\n        errorParams = {\n          status,\n          message: errorText,\n          errorCode: status,\n          requestUrl: request.url\n        };\n      } else {\n        errorParams = {\n          status: 9999,\n          message: '网络错误',\n          errorCode: 9999,\n          requestUrl: request.url\n        };\n      }\n\n      return Promise.reject(new ResError(errorParams));\n    }\n\n    instance.interceptors.response.use(interceptors.resHandler || (res => res), interceptors.errHandler || resErrorFn);\n  }\n\n  head(url) {\n    return this.instance.head(url);\n  }\n\n  async get(url, params = {}, config = {}) {\n    const res = await this.instance.get(url, _objectSpread(_objectSpread({}, config), {}, {\n      params\n    }));\n    return res.data;\n  }\n\n  delete(url) {\n    return this.instance.delete(url);\n  }\n\n  async post(url, data, config) {\n    const res = await this.instance.post(url, data, config);\n    return res.data;\n  }\n\n  put(url, data, config) {\n    return this.instance.put(url, data, config);\n  }\n\n  patch(url, data, config) {\n    return this.instance.patch(url, data, config);\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}